% =======================================================================
% Semantics
% =======================================================================

\section{TA Generator}
\begin{frame}[shrink=5]{TA Generator}
    \begin{center}
        \input{Documents/Diagrams/TreatDiagram.tex}
    \end{center}
\end{frame}
\begin{frame}[fragile]{Match semantics}
    \begin{definition}
        Assarin et al.
        
        The automaton for \underline{$[\![a]\!]$}, $a\in\Sigma$ is $(\{s,f\},\emptyset,\Delta,\Sigma,s,\{f\})$ where the transition relation is $\Delta={(s,true,\emptyset,a,f)}$.
    \end{definition}
        
    \begin{lstlisting}[style=csharp,basicstyle=\small]
void Visit(Match match)
{
    TimedAutomaton ta = new(_regex);
    
    State initial = ta.AddState(newInitial: true);
    State final = ta.AddState(true);

    ta.AddEdge(initial, final, match.Token.Match);

    _stack.Push(ta);
}
    \end{lstlisting}
\end{frame}

\begin{frame}{Union semantics}
    \begin{definition}
        
        Assarin et al.
        
        The automaton for $[[\varphi_1\vee\varphi_2]]$ is $(Q_1\cup Q_2 \cup \{s\},C_1\cup C_2,\Delta,\Sigma,s,F_1\cup F_2)$, where $\Delta$ is constructed
        by adding to $\Delta_1\cup \Delta_2$ two new $\epsilon$-transitions $(s, x = 0,\emptyset,\epsilon,s_i)$, where $x$ is any clock and $i\in{1,2}$
        (if there is no clock in the automata we should add one).
    \end{definition}

    \input{Automata/AsarinUnion.tex}
    \input{Automata/CustomUnion.tex}
\end{frame}

\begin{frame}{Union semantics revised}
    \input{Documents/Definitions/PruneSemantics/Union.tex}
\end{frame}

\begin{frame}[fragile]{Union implementation}
    \begin{lstlisting}[style=csharp,basicstyle=\tiny]
(TimedAutomaton right, TimedAutomaton left) = (_stack.Pop(), _stack.Pop());
EpsilonConcat(right);
EpsilonConcat(left);
TimedAutomaton ta = new(left, right, e => IsNotInitial(e.From), IsNotInitial);

State initial = ta.AddState(newInitial: true);

foreach (Edge edges in left.GetEdgesFrom(left.InitialState!)
    .Concat(right.GetEdgesFrom(right.InitialState!)))
{
    Edge e = ta.AddEdge(initial, edges.To, edges.Symbol);
    e.AddClockRanges(edges.GetClockRanges());
    e.AddClockResets(edges.GetClockResets());
}

static void EpsilonConcat(TimedAutomaton ta)
{
    if (ta.GetEdgesTo(ta.InitialState!).Any())
    {
        State oldInitial = ta.InitialState!;
        State newInitial = ta.AddState(ta.IsFinal(oldInitial), true);
        Edge edge = ta.AddEdge(newInitial, oldInitial, "\0");
    }
}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Lazy intersection}
    Lazily generate new states
    \begin{lstlisting}[style=csharp,basicstyle=\tiny]
State GetNewState(State lState, State rState)
{
    if (!newLocs.TryGetValue((lState, rState), out State? state))
    {
        state = ta.AddState();
        newLocs[(lState, rState)] = state;
    }

    return state;
}
    \end{lstlisting}
\end{frame}

% =======================================================================
% Timed word generator
% =======================================================================
\section{Timed words}
\begin{frame}[shrink=5]{Timed words}
    \begin{center}
        \input{Documents/Diagrams/TreatDiagram.tex}
    \end{center}
\end{frame}
\begin{frame}[fragile]{Timed word generation}
    \begin{columns}
        \begin{column}{0.6\textwidth}
            nasa.gov
            \begin{lstlisting}[basicstyle=\tiny]
00 00 00 04 CDR
Roger. Clock.

00 00 00 13 CDR
Roger. We got a roll program.

00 00 00 15 CMP
Roger. Roll.

00 00 00 34 CDR
Roll's complete and the pitch is programed.

00 00 00 44 CDR
One Bravo.

00 00 01 02 CC
Apollo 11, Houston. You're good at 1 minute.
...
            \end{lstlisting}
        \end{column}
        \begin{column}{0.4\textwidth}
            apollo11transcript.csv
            \begin{lstlisting}[basicstyle=\tiny]
CDR, 4


CDR, 13


CMP, 15


CDR, 34


CDR, 44


CC, 62

...
            \end{lstlisting}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Words as timed automata}
    In UPPAAL
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \input{Automata/Word.tex}

        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{lstlisting}[basicstyle=\tiny]
update: index++
guard: index <= 8439 &&
    word[index] == "CDR" &&
    times[index] == c0
            \end{lstlisting}
        \end{column}
    \end{columns}
    \begin{lstlisting}[basicstyle=\tiny]
clock c0;
int32_t index = 0;
const string word[8439] = {"CDR", "CDR", "CMP", "CDR", "CDR", "CC", ... }
clock_t times[8439] = {4, 13, 15, 34, 44, 62, ... }
    \end{lstlisting}
\end{frame}

% =======================================================================
% Pruning
% =======================================================================
\section{Pruning}
\begin{frame}[shrink=5]{Pruning}
    \begin{center}
        \input{Documents/Diagrams/TreatDiagram.tex}
    \end{center}
\end{frame}
\begin{frame}{Clock reduction}
    Daws et al.

    $$C(A[5;10]\&(BA|A)[1;3])$$
    \input{Automata/Prune0.tex}
\end{frame}
\begin{frame}{Dead transition}
    \input{Documents/Definitions/PruneSemantics/DeadEdge.tex}
    \input{Automata/Prune1.tex}
\end{frame}
\begin{frame}{Unreachable state}
    \input{Documents/Definitions/PruneSemantics/Unreachable.tex}
    \input{Automata/Prune2.tex}
\end{frame}
\begin{frame}{Dead state}
    \input{Documents/Definitions/PruneSemantics/DeadState.tex}
    \input{Automata/Prune3.tex}
\end{frame}
\begin{frame}{Dead clock}
    \input{Documents/Definitions/PruneSemantics/DeadClock.tex}
    \input{Automata/Prune4.tex}
\end{frame}
\begin{frame}{Recursion}
    \input{Documents/Definitions/PruneSemantics/RecursivePruning.tex}
    \input{Automata/Prune5.tex}
    \input{Automata/Prune6.tex}
\end{frame}

\begin{frame}{Recursion}
    \input{Documents/Definitions/PruneSemantics/RecursivePruning.tex}
    \input{Documents/Diagrams/RecursionDependency.tex}
\end{frame}

% =======================================================================
% Graph layout
% =======================================================================
\section{Graph}
\begin{frame}[shrink=5]{Graph}
    \begin{center}
        \input{Documents/Diagrams/TreatDiagram.tex}
    \end{center}
\end{frame}
\begin{frame}{Sugiyama Framework}
    We dont need precise algorithm
    \begin{itemize}
        \item Make graph acyclic (trivial)
        \item Assign states to layers
        \item Order states in layers (just needs to be good enough)
        \item Assign positions (simplicity over correctness)
    \end{itemize}
\end{frame}

\begin{frame}[fragile,shrink=5]{Creation of recursive edges}
    \begin{definition}Asarin et al. (Guaranteed iterator)

        The automaton for $[\![\varphi^+_1 ]\!]$ is $A = (Q_1,C_1,\Sigma,\Delta,s_1,F_1)$ where $\Delta_1$ is constructed from $\Delta_1$ by adding
        for every transition of the form $(q,\varphi,p,a, f_1)$ in $\Delta_1$ with $f_1 \in F_1$ a transition of the form
        $(q,\varphi,C_1,a,s_1)$.
    \end{definition}
        
    \begin{definition}
        Asarin et al. (Absorbed guaranteed iterator)

        The automaton for $[\![\varphi^\oplus_1 ]\!]$ is $A = (Q_1 \times 2^{C_1}, C_1 \cup \{x\},\Sigma,\Delta,(s_1,\emptyset),F_1 \times 2^{C_1})$. The second component of the state records which clocks have been reset during the current iteration of $[\![\varphi_1]\!]$.
        There are two types of transitions in $\Delta$:
        \begin{itemize}
            \item Transitions simulating those of $A$ : for every transition of the form $(q,\varphi,p,a,q)$ in $\Delta_1$
            and every $D \subset C_1$ the relation $\Delta$ contains $((q,D),\varphi_D,p,a,(q',D\cup p))$
            \item Looping transitions: for every transition of the form $(q_1,\varphi,p,a, f_1)$ in $\Delta_1$ with $f_1 \in F_1$ and
            every $D \subset C_1$ the relation $\Delta$ contains $((q_1,D),\varphi_D,p,a,(s_1,\emptyset))$.
        \end{itemize}
        Here $\varphi_D$ is obtained by replacing in $\varphi$ all occurrences of clocks not belonging to $D$ by $x$
    \end{definition}
\end{frame}
    
\begin{frame}[fragile]{Keeping reversible edges (1)}
    \begin{definition}
        Asarin et al. (Absorbed guaranteed iterator)

        The automaton for $[\![\varphi^\oplus_1 ]\!]$ is $A = (Q_1 \times 2^{C_1}, C_1 \cup \{x\},\Sigma,\Delta,(s_1,\emptyset),F_1 \times 2^{C_1})$. The second component of the state records which clocks have been reset during the current iteration of $[\![\varphi_1]\!]$.
        There are two types of transitions in $\Delta$:
        \begin{itemize}
            \item Transitions simulating those of $A$ : for every transition of the form $(q,\varphi,p,a,q)$ in $\Delta_1$
            and every $D \subset C_1$ the relation $\Delta$ contains $((q,D),\varphi_D,p,a,(q',D\cup p))$
            \item Looping transitions: for every transition of the form $(q_1,\varphi,p,a, f_1)$ in $\Delta_1$ with $f_1 \in F_1$ and
            every $D \subset C_1$ the relation $\Delta$ contains $((q_1,D),\varphi_D,p,a,(s_1,\emptyset))$.
        \end{itemize}
        Here $\varphi_D$ is obtained by replacing in $\varphi$ all occurrences of clocks not belonging to $D$ by $x$
    \end{definition}
\end{frame}
\begin{frame}[fragile]{Keeping reversible edges (2)}
    \begin{definition}
        The automaton for $[\![\varphi_1\wedge\varphi_2]\!]$ is $(Q_1\times Q_2 \cup \{f\}, C_1\cup C_2,\Delta,\Sigma,(s_1,s_2),\{f\})$, where $\Delta$ contains
        \begin{itemize}
            \item a transition $\{((q_1,q_2),\Phi_1\wedge\Phi_2,p_1\cup p_2, a, (q'_1,q'_2))$for any$(q_1,\Phi_1,p_1,a,q'_1)\in\Delta_1$and any$(q_2,\Phi_2,p_2,a,q'_2)\in\Delta_2\}$;
            \item a transition $\{((q_1,q_2),\Phi_1\wedge\Phi_2,p_1\cup p_2, a, f)$for any$(q_1,\Phi_1,p_1,a,f'_1)\in\Delta_1$and any$(q_2,\Phi_2,p_2,a,f'_2)\in\Delta_2\}$ where $f_1\in F_1$ and $f_2\in F_2$;
            \item a transition $\{((q_1,q_2),\Phi_1,p_1,\epsilon,(q'_1,q))$for any$(q_1,\Phi_1,p_1,\epsilon,q'_1)\in\Delta_1\}$;
            \item a transition $\{((q_1,q_2),\Phi_2,p_2,\epsilon,(q,q'_2))$for any$(q_2,\Phi_2,p_2,\epsilon,q'_2)\in\Delta_2\}$;
        \end{itemize}
    \end{definition}

    % \begin{lstlisting}[style=csharp,basicstyle=\tiny]
    %     State GetNewState(State lState, State rState)
    %     {
    %         if (!newLocs.TryGetValue((lState, rState), out State? state))
    %         {
    %             state = ta.AddState();
    %             newLocs[(lState, rState)] = state;
    %         }
        
    %         return state;
    %     }
    % \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Removing recursive edges}
    In graphlayout
    \begin{lstlisting}[style=csharp,basicstyle=\tiny]
private void AssignLayers(TimedAutomaton ta, TaState taState, int layerIndex)
...
foreach (Edge edge in ta.GetEdgesFrom(taState)
    .Where(e => !e.IsReversible))
    ...
foreach (Edge edge in ta.GetEdgesTo(taState)
    .Where(e => e.IsReversible && !e.To.Equals(taState)))
    ...
...
    \end{lstlisting}
\end{frame}