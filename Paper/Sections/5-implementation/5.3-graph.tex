\subsection{Graph Layout}

% Motivation for implementing algorithm ourselves
%   - alternative: use DOT language for Graphviz. 
%       - too much bloat and better understanding of algorithm if implemented manually
% Sugiyama framework
%   - 4 steps
%       - make graph acyclic
%           - mention trivial solution?
%       - assign states to layers
%       - order states in layers
%       - assign positions


% (CDE|(BC)+)|A works well in step 1 and 3, but it does not change from 2 to 3. I can use the reverse tregex in step 2: A|((BC)+|CDE)

% automaton is also missing dummy states

As mentioned earlier, the layout algorithm used in (TODO: Insert name of program) to organize and arrange the states in timed automata, is called the Sugiyama framework, also known as layered graph drawing (TODO: cite sugiyama when \#343 merged). The method comprises four steps that, when combined, results in a layered graph with minimized edge crossings. These steps are discussed below, using the timed automaton shown below, which was constructed using the following timed regular expression: $$"(CDE\mid(BC)+)\mid A"$$

% Visualise steps with different automata
\input{Documents/Diagrams/GraphFigures/graphstep0.tex}

\subsubsection{Make automata acyclic}
The first step of the Sugiyama framework is to, temporarily, make the automata acyclic. This is necessary because subsequent steps require edges to have a consistent direction. As described by Mazetti et al., this is done by reversing a specific list of edges \cite{Mazetti2012}.
Mazetti describes several methods for finding this list of edges, including using a depth first search to visit all states, and any edges that lead to already visited states, should be reversed.
This is the method used by Graphviz' implementation of the Sugiyama framework \cite{Graphviz}. % could be irrelevant

This step, however, is trivially completed during the conversion from a timed regular expression to a timed automaton, since the semantics described by Eugene et al. precisely describe when reversible edges are created.
More specifically, in the construction of guaranteed iterator automata, and it's absorbed variant\cite{Eugene2001}.
% mention self loops

% insert image of step
\input{Documents/Diagrams/GraphFigures/graphstep1.tex}

\subsubsection{Assign states to layers}
The next step is to assign states to layers. Mazetti et al. describes this process by assigning a given state to the layer index equal to the longest path from the initial state. If an edge spans multiple layers, dummy states are placed to ensure that edges only move between adjacent layers. \cite{Mazetti2012}

This has been implemented by assigning the initial state of the automaton to layer 0, and assigning the states connected by outgoing edges to layer 1.
This is done recursively for all outgoing states until a final state is reached.
If, at any point, a state is reached that is on the same layer or lower, it is moved to the next layer, and its outgoing states are recursively updated as well.
Dummy states are introduced if two connected states are more than one layer apart.

% insert image of step
\input{Documents/Diagrams/GraphFigures/graphstep2.tex}

\subsubsection{Order states in layers}
After all states have been assigned to a layer, they are ordered in those layers to ensure the smallest number of edge crossings, which, more often than not, degrades the visual clarity of the automata.
Mazetti et al. formulates this by sweeping through each layer and ordering its states by the barycenter (average) of the positions of its connected states in the previous layer.
E.g. if a state is connected to two states in the previous layer, and their positions are (0, 0) and (0, 100), the given state's position would be (100, 50).
This sweep is performed thrice, once forward, once backwards, and lastly, forward again.
This ensures that both a given state's incoming and outgoing states play a role in minimizing edge crossings. \cite{Mazetti2012}

The approach implemented for this paper shares the same philosophies as the step described above.

% insert image of step
\input{Documents/Diagrams/GraphFigures/graphstep3.tex}

\subsubsection{Assign positions}
The last step is to assign positions to each state.
Mazetti et al.'s procedure for this step is to prioritze all states in each layer based on the number of connected states in the previous layer.
More connections give a higher priority. This is quite similar to the previous step except, dummy states are given the highest prioritization.
Each state is placed based on their priority, with the ability to move states with lower priority.
Lastly, edges between dummy states are merged, and restoring the correct edge oritentations that were reversed in the first step. \cite{Mazetti2012}

As of writing this paper, this apporach has not yet been implemented. Instead, states are simply placed based on their layer, and their index on said layer, which already offers much visual clarity. The cycles are reintroduced at the very end of this step.

% insert image of step
\input{Documents/Diagrams/GraphFigures/graphstep4.tex}
