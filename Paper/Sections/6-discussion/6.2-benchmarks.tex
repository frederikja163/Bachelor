\subsection{Benchmark UPPAAL}\label{sub:benchmark_uppaal}
More states should intuitively mean UPPAAL runs slower, however this might not be the case if these extra states are easily pruneable.
Therefore we tried running the same query twice in UPPAAL on a large timed word.
The timed word used in these examples are 34198 timed characters long, and the last character happens at time 238817.
The data of these benchmarks can be found on \cref{table:uppaal_benchmarks}.

\input{Documents/Tables/UppaalBenchmarks.tex}

As can be seen on \cref{table:uppaal_benchmarks}, checking is faster with pruning.
This points to UPPAAL not pruning the unnecessary states when checking.
So pruning not only helps with readability, it also helps with performance. 

\subsection{Benchmark TREAT}
\subsubsection{Setup}
Next step is checking if the prunings have an effect on performance on TREAT.
The original implementation pruned steps after generating the entire automaton.
However it might be faster if we prune while generating the automaton.
Therefore we have created a series of regular expressions, and test configurations to put them all against each other and see how each perform.
Each configuration is a mix of pruning before and after generation of the automaton.

\begin{enumerate}
    \item \textbf{N}: This configuration has no pruning.
    \item \textbf{S}: This configuration prunes only states after generation.
    \item \textbf{E}: This configuration prunes everything after generation.
    \item \textbf{SS}: This configuration prunes states during generation and everything after generation.
    \item \textbf{SE}: This configuration prunes states during generation and only states after generation.
    \item \textbf{ES}: This configuration prunes everything during generation and only states after generation.
    \item \textbf{EE}: This configuration prunes everything during generation and everything after generation.
\end{enumerate}

Note: When we say prune during generation, we are talking about pruning the operands of the explosive operators.
This means the left and right operand of an intersection and the single operand of an absorbed iterator.

As for the tests we have generated 6 parameterized TREs, that we use to generate a total of 19 unique TREs.
Each TRE serves a unique purpose.
All these TREs can be found in \cref{app:RegularExpressionTable}.

TRE $a$, $b$ and $f$ were all chosen because they would benefit pruning while generating.
Serving as a best case scenario for SS, SE, ES and EE.
The theory being these configurations limit the amount of states used in the explosive operators, therefore making them less explosive.
Ideally it should make them resemble a linear complexity, since the final TAs are of constant length.

TRE $c$, $d$ and $e$ where all chosen to benefit no pruning while generating.
Serving as a best case scenario for N, S and E.
The theory being these regular expressions wont benefit from pruning while generating, since a limited or no pruning can be done during generation.

\subsubsection{Results}
The results can be split into 3 main categories.

\begin{enumerate}
    \item Equivalent performance between configurations.
    \item SS, SE, ES and EE configurations are better.
    \item N, S, SS configurations are better.
\end{enumerate}

All the plots can be seen on \cref{TODO}, with all the data on \cref{TODO}, however a few will be presented here.

The TREs $a$, $b$, $d$ and $e$ are all equivalent in performance.
By this we mean their graphs are all curved in the same way, and they are within a few percent of each other.
An example of this can be seen on \cref{fig:mean3-5} (this is the one with the biggest difference in this category).

\input{Documents/Plots/Mean/3-5.tex}
\captionof{figure}{Graph for runtime of regular expression 3-5 ($b$).}
\label{fig:mean3-5}

Since we were expecting $a$ and $b$ to be more performant on SS, SE, ES and EE, this result is not what we expected.
After opening up one of the automata (\cref{fig:FailedAutomata}) we can see state $q1$ should have been pruned, since it can never be reached from the starting state.
However it is not pruned, because it is neither unreachable nor dead because of the self loop.
So we have a problem where a loop to a state itself will keep a state throughout our pruning rules.

\input{Automata/FailedPruning.tex}

Creating bigger automata only expands on this problem. This is something that could be fixed, but for now we are leaving it as is.

The TRE $f$ performs better on SS, SE, ES and EE.
This graph can be seen on \cref{fig:mean15-19}.
This is the kind of performance difference we expected, and proves pruning while generation is a lot better for intersection.

\input{Documents/Plots/Mean/15-19.tex}
\captionof{figure}{Graph for runtime of regular expression 15-19 ($f$).}
\label{fig:mean15-19}

Finally the TRE $c$ performs better on N, S and SS.
This graph can be seen on \cref{fig:mean6-8}
This is probably because the pruning of everything is too expensive in terms of time and memory for it to make sense for this automaton.
While this is an interesting result, it does not mean these prunings are better, since they dont get rid of all the extra states.

\input{Documents/Plots/Mean/6-8.tex}
\captionof{figure}{Graph for runtime of regular expression 6-8 ($c$).}
\label{fig:mean6-8}

\subsubsection{Conclusions}
We have shown that in UPPAAL you can gain significant performance by pruning the states.
So pruning should be worth it to do most of the time, since pruning is a startup cost.

Pruning by itself can lead to really explosive performance on some regular expressions.
Even if we prune while the automaton is generating.
However in the large picture it seems like pruning during has the ability to turn some generations from parabolic to linear.